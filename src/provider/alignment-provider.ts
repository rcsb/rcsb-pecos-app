
import { AppConfigs } from '..';
import { StructureAlignmentQuery } from '../auto/alignment/alignment-request';
import { StructureAlignmentResponse } from '../auto/alignment/alignment-response';
import { isEntry } from '../utils/helper';
import { QueryOptionsImpl, QueryRequest } from '../utils/request';

type AlignmentProviderConfigs = AppConfigs['service']['alignment'];
export class StructureAlignmentProvider {

    private readonly _config;
    private readonly waitMs = 1000;
    private readonly timeoutMs = 300 * 1000;

    constructor(config: AlignmentProviderConfigs) {
        this._config = config;
    }

    private submitURL() {
        return this._config.base + '/' + this._config.submit;
    }

    private resultsURL() {
        return this._config.base + '/' + this._config.results;
    }

    /**
     * Submits structure alignment query to the alignment service
     *
     * @param request structure alignment query object that describes the alignment job
     * @returns a unique request ID (UUID) generated at each HTTP request received by the alignment service
     */
    async submit(request: QueryRequest): Promise<string> {
        const data = toFormData(request.query, request.files);
        return fetch(this.submitURL(), {
            method: 'POST',
            body: data,
            headers: this._config.httpHeaders
        }).then(async response => {
            if (response.status === 200)
                return response.text();
            const error = await response.json();
            throw new Error(`Failed to submit the job to the server: ${this.submitURL}. HTTP ${error.status}: ${error.message}`);
        });
    }

    /**
     * Get structure alignment results calculated by the alignment service
     *
     * @param uuid a unique request ID generated by alignment service
     * @returns structure alignment data
     */
    async results(uuid: string): Promise<StructureAlignmentResponse> {
        const start = Date.now();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // check if had to wait for too long before continue to poll
            if (this.timeoutMs !== 0 && Date.now() - start > this.timeoutMs) {
                throw new Error('Did not receive complete results within the time that was prepared to wait');
            }
            const job = await this.poll(uuid);
            if (job.info.status === 'RUNNING') {
                await this.sleep();
            } else if (job.info.status === 'COMPLETE' || job.info.status === 'ERROR') {
                return job;
            } else {
                throw new Error(`Unexpected job status: ${job.info.status}`);
            }
        }
    }

    private async poll(uuid: string): Promise<StructureAlignmentResponse> {
        const url = this.resultsURL() + '?uuid=' + uuid;
        const response = await fetch(url, { method: 'get' });
        if (response.ok) {
            return await response.json();
        } else if (response.status === 404) {
            throw new Error(`The job results are unavailable. UUID: [ ${uuid} ] can be wrong or the results were already claimed`);
        } else {
            throw new Error(`Fatal error occurred: ${response.statusText}`);
        }
    }

    private sleep() {
        return new Promise(resolve => setTimeout(resolve, this.waitMs));
    }
}

function returnSequenceData(query: StructureAlignmentQuery) {
    for (const s of query.context.structures) {
        if (!isEntry(s)) return true;
    }
    return false;
}

function toFormData(query: StructureAlignmentQuery, files?: File[]): FormData {
    if (returnSequenceData(query)) {
        const opts = new QueryOptionsImpl();
        opts.return_sequence_data = true;
        query.options = opts;
    }
    const data = new FormData();
    data.append('query', JSON.stringify(query));
    files?.map(f => data.append('files', f));
    return data;
}