/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type StructureFileFormat = 'pdb' | 'mmcif';

/**
 * Structure alignment query object that describes the alignment job
 */
export interface StructureAlignmentQuery {
    options?: AlignmentQueryOptions;
    context: PairwiseStructureAlignment;
}
export interface AlignmentQueryOptions {
    /**
     * When set to true, polymer sequence (one-letter residue codes) is returned as a part of sequence alignment results (alongside the alignment boundaries). When set to false, only alignment boundaries are returned
     */
    return_sequence_data?: boolean;
}
/**
 * Pairwise alignment of protein structures
 */
export interface PairwiseStructureAlignment {
    mode: 'pairwise';
    method: TMAlign | JFATCATRigid | JFATCATFlexible | JCE | JCECP | SmithWaterman3D | QCP;
    /**
     * Input for structure alignment algorithm
     */
    structures: (StructureEntry | StructureFileUpload | StructureWebLink)[];
}
/**
 * TM-align uses heuristic dynamic programming iterations to generate sequence independent residue-to-residue alignment based on structural similarity.
 */
export interface TMAlign {
    name: 'tm-align';
}
/**
 * Java implementation of the original FATCAT algorithm. The 'rigid' flavor uses a rigid-body superposition and only considers alignments with matching sequence order.
 */
export interface JFATCATRigid {
    name: 'fatcat-rigid';
    parameters?: JFATCATRigidParameters;
}
/**
 * Parameters for the jFATCAT-rigid algorithm.
 */
export interface JFATCATRigidParameters {
    /**
     * Configures RMSD cutoff for AFP detection.
     */
    rmsd_cutoff?: number;
    /**
     * Configures the distance cutoff used when calculating connectivity of AFP pairs.
     */
    afp_dist_cutoff?: number;
    /**
     * Configures the length of the fragments.
     */
    fragment_length?: number;
}
/**
 * Java implementation of the original FATCAT algorithm that allows circularly permuted proteins to be compared.
 */
export interface JFATCATFlexible {
    name: 'fatcat-flexible';
    parameters?: JFATCATFlexibleParameters;
}
/**
 * Parameters for the jFATCAT-flexible algorithm.
 */
export interface JFATCATFlexibleParameters {
    /**
     * Configures RMSD cutoff for AFP detection.
     */
    rmsd_cutoff?: number;
    /**
     * Configures the distance cutoff used when calculating connectivity of AFP pairs.
     */
    afp_dist_cutoff?: number;
    /**
     * Configures the length of the fragments.
     */
    fragment_length?: number;
    /**
     * Configures the number of twists that are allowed to be introduced. If set to 0 alignments are run in rigid mode.
     */
    max_num_twists?: number;
}
/**
 * Java port of the Combinatorial Extension (CE) algorithm. CE obtains an optimal rigid-body superposition of the proteins by employing a combinatorial extension (CE) of an alignment path defined by aligned fragment pairs (AFPs).
 */
export interface JCE {
    name: 'ce';
    parameters?: JCEParameters;
}
/**
 * Parameters for the jCE algorithm.
 */
export interface JCEParameters {
    /**
     * Configures the maximum gap size G, that is applied during the AFP extension. There is a trade-off between performance and result accuracy, setting a larger number increases the calculation time, but may produce a longer alignment. To remove the restriction on the parameter G set value to 0.
     */
    gap_max_size?: number;
    /**
     * This parameter configures gap opening penalty during alignment optimization.
     */
    gap_opening_penalty?: number;
    /**
     * Configures gap extension penalty during alignment optimization.
     */
    gap_extension_penalty?: number;
    /**
     * Configures a fragment size of Aligned Fragment Pairs (AFPs).
     */
    fragment_size?: number;
    /**
     * Configures RMSD threshold used while tracing the Aligned Fragment Pair (AFP) fragments.
     */
    rmsd_threshold?: number;
    /**
     * Configures maximum RMSD at which to stop alignment optimization.
     */
    max_opt_rmsd?: number;
}
/**
 * Combinatorial Extension with Circular Permutations (CE-CP) allows the structural comparison of circularly permuted proteins.
 */
export interface JCECP {
    name: 'ce-cp';
    parameters?: JCECPParameters;
}
/**
 * Parameters for the jCE-CP algorithm.
 */
export interface JCECPParameters {
    /**
     * Configures the maximum gap size G, that is applied during the AFP extension. There is a trade-off between performance and result accuracy, setting a larger number increases the calculation time, but may produce a longer alignment. To remove the restriction on the parameter G set value to 0.
     */
    gap_max_size?: number;
    /**
     * This parameter configures gap opening penalty during alignment optimization.
     */
    gap_opening_penalty?: number;
    /**
     * Configures gap extension penalty during alignment optimization.
     */
    gap_extension_penalty?: number;
    /**
     * Configures a fragment size of Aligned Fragment Pairs (AFPs).
     */
    fragment_size?: number;
    /**
     * Configures RMSD threshold used while tracing the Aligned Fragment Pair (AFP) fragments.
     */
    rmsd_threshold?: number;
    /**
     * Configures maximum RMSD at which to stop alignment optimization.
     */
    max_opt_rmsd?: number;
    /**
     * Configures minimum length for a CP block to consider.
     */
    min_cp_length?: number;
}
/**
 * Aligns residues based on Smith and Waterman algorithm for local sequence alignment using Blosum65 scoring matrix. Then structures are superimposed based on this alignment.
 */
export interface SmithWaterman3D {
    name: 'smith-waterman-3d';
    parameters?: SmithWatermanParameters;
}
/**
 * Parameters for the Smith-Waterman 3D algorithm.
 */
export interface SmithWatermanParameters {
    /**
     * This parameter configures gap opening penalty.
     */
    gap_opening_penalty?: number;
    /**
     * Configures gap extension penalty.
     */
    gap_extension_penalty?: number;
}
/**
 * Aligns equal-sized residue sets by their Quaternion-Based Characteristic Polynomial. QCP requires two or more Motif queries and cannot handle any other input types.
 */
export interface QCP {
    name: 'qcp';
    parameters?: QCPParameters;
}
/**
 * Parameters for the Quaternion-Based Characteristic Polynomial algorithm.
 */
export interface QCPParameters {
    /**
     * This parameter configures which atoms are paired. Options are 'all' (all atom), 'backbone' (all backbone atoms), 'side-chain' (all side-chain atoms), 'pseudo-atoms' (alpha and beta carbons).
     */
    atom_pairing_strategy?: 'all' | 'backbone' | 'side-chain' | 'pseudo-atoms';
}
/**
 * Structure available in the PDB archive
 */
export interface StructureEntry {
    entry_id: string;
    selection?: StructureInstanceSelection | StructureMotifSelection;
}
export interface StructureInstanceSelection {
    /**
     * Case sensitive chain ID (label_asym_id)
     */
    asym_id: string;
    /**
     * First residue number as it appears in the deposited sequences. In mmCIF terminology it corresponds to label_seq_id
     */
    beg_seq_id?: number;
    /**
     * Last residue number as it appears in the deposited sequences. In mmCIF terminology it corresponds to label_seq_id
     */
    end_seq_id?: number;
}
export interface StructureMotifSelection {
    /**
     * Collection of residue identifiers
     */
    residue_ids: ResidueIdentifier[];
}
export interface ResidueIdentifier {
    /**
     * Chain identifier of this residue. In mmCIF terminology it corresponds to label_asym_id
     */
    asym_id: string;
    /**
     * Identifier of the assembly generating operation that was used to determine the coordinates of this residue. Chaining of operations is expressed by '1stx2nd'.
     */
    struct_oper_id?: string;
    /**
     * Sequence identifier of this residue. In mmCIF terminology it corresponds to label_seq_id
     */
    seq_id: number;
}
/**
 * Structure provided via web-link or via uploading the file content together with the query
 */
export interface StructureFileUpload {
    format: StructureFileFormat;
    selection?: StructureInstanceSelection | StructureMotifSelection;
}
/**
 * Structure provided via web-link or via uploading the file content together with the query
 */
export interface StructureWebLink {
    /**
     * File will be fetched from the specified location
     */
    url: string;
    format: StructureFileFormat;
    name?: string;
    selection?: StructureInstanceSelection | StructureMotifSelection;
}
