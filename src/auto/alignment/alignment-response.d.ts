/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type StructureFileFormat = 'pdb' | 'mmcif';

/**
 * Container for structure alignment results
 */
export interface StructureAlignmentResponse {
    info: ResponseInfo;
    meta?: StructureAlignmentMetadata;
    /**
     * Stores of a set of alignment alternatives or solutions
     */
    results?: Alignment[];
}
/**
 * Provides additional metadata about a job
 */
export interface ResponseInfo {
    /**
     * Unique job ID
     */
    uuid: string;
    /**
     * Indicates whether a job is successfully completed, in progress or resulted in error
     */
    status: 'RUNNING' | 'COMPLETE' | 'ERROR';
    /**
     * Provides additional information about the request
     */
    message?: string;
}
export interface StructureAlignmentMetadata {
    alignment_mode: 'pairwise' | 'multiple';
    alignment_method?: string;
}
/**
 * Store the core information of a structure alignment
 */
export interface Alignment {
    /**
     * Identifies aligned structures
     */
    structures: (StructureEntry | StructureURL)[];
    /**
     * List of size K that holds structural alignment data, where K - number of blocks. Blocks divide the alignment into structurally equivalent parts. The division can be due to non-topological rearrangements (e.g. circular permutations) or due to flexible parts (e.g. domain or region swaps).
     */
    structure_alignment: StructureAlignmentBlock[];
    /**
     * List of size M that codifies sequence alignment, where M - the number of aligned structures
     */
    sequence_alignment?: SequenceAlignment[];
    summary?: AlignmentSummary;
}
/**
 * Structure available in the PDB archive
 */
export interface StructureEntry {
    entry_id: string;
    selection?: StructureInstanceSelection | StructureMotifSelection;
}
export interface StructureInstanceSelection {
    /**
     * Case sensitive chain ID (label_asym_id)
     */
    asym_id: string;
    /**
     * First residue number as it appears in the deposited sequences. In mmCIF terminology it corresponds to label_seq_id
     */
    beg_seq_id?: number;
    /**
     * Last residue number as it appears in the deposited sequences. In mmCIF terminology it corresponds to label_seq_id
     */
    end_seq_id?: number;
}
export interface StructureMotifSelection {
    /**
     * Collection of residue identifiers
     */
    residue_ids: ResidueIdentifier[];
}
export interface ResidueIdentifier {
    /**
     * Chain identifier of this residue. In mmCIF terminology it corresponds to label_asym_id
     */
    asym_id: string;
    /**
     * Identifier of the assembly generating operation that was used to determine the coordinates of this residue. Chaining of operations is expressed by '1stx2nd'.
     */
    struct_oper_id?: string;
    /**
     * Sequence identifier of this residue. In mmCIF terminology it corresponds to label_seq_id
     */
    seq_id: number;
}
/**
 * Structure provided via web-link or via uploading the file content together with the query
 */
export interface StructureURL {
    /**
     * File will be fetched from the specified location
     */
    url: string;
    format: StructureFileFormat;
    is_binary: boolean;
    name?: string;
    selection?: StructureInstanceSelection | StructureMotifSelection;
}
/**
 * Stores a sequential (reverse or forward) part of a structural alignment: aligned positions and 3D transformations
 */
export interface StructureAlignmentBlock {
    /**
     * List of size M that describes structurally equivalent residues, where M - the number of aligned structures
     */
    regions?: AlignmentRegion[][];
    /**
     * List of size M that holds block transformations, where M - the number of aligned structures. Each transformation is a 4x4 matrix in a column major (j * 4 + i indexing) format.
     */
    transformations: number[][];
    summary?: AlignmentSummary;
}
export interface AlignmentRegion {
    /**
     * Chain ID assigned by the PDB (or selected by the author at the time of deposition)
     */
    asym_id: string;
    /**
     * PDB residue number of the alignment position (sequential number from 1-N to match residues as they appear in the deposited sequences)
     */
    beg_seq_id: number;
    /**
     * 0-based index of the alignment position in sequence alignment
     */
    beg_index: number;
    length: number;
}
export interface AlignmentSummary {
    scores?: {
        /**
         * Similarity score value
         */
        value?: number;
        /**
         * Similarity score type: RMSD: a simple root mean square deviation between the superposed residues; TM-score: template modeling score - topological similarity of structures; similarity-score: similarity score specific to the method; sequence-identity: the percent of residues in the alignment that are sequence-identical; sequence-similarity: the percent of residues in the alignment that are sequence-similar
         */
        type?: 'RMSD' | 'TM-score' | 'similarity-score' | 'sequence-similarity' | 'sequence-identity';
    }[];
    /**
     * Number of residue (alpha carbon) pairs matched by the superposition
     */
    n_aln_residue_pairs?: number;
    /**
     * Number of residues with coordinates used for structure alignment
     */
    n_modeled_residues?: number[];
    /**
     * Sequence alignment length (including gaps)
     */
    seq_aln_len?: number;
    /**
     * Fraction of residues matched by the superposition (related by spacial proximity) relative to the total number of modeled residues being aligned
     */
    aln_coverage?: number[];
}
/**
 * Codifies the alignment data a sequence of one-letter residue codes and the information on the chain and residue numbers for the aligned regions
 */
export interface SequenceAlignment {
    /**
     * A sequence of one-letter residue codes in the order they appear in the alignment (gap characters are permitted). Gaps that have been introduced into the sequences to make them align are indicated by the '-' character
     */
    sequence?: string;
    regions: AlignmentRegion[];
    /**
     * List of empty regions (gaps) in the alignment sequence
     */
    gaps?: AlignmentGap[];
}
/**
 * Defines the placement of introduced gaps in sequence alignment
 */
export interface AlignmentGap {
    /**
     * 0-based index of the alignment position in sequence alignment
     */
    beg_index: number;
    length: number;
}
