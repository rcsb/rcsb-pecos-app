
import { AppConfigs } from '..';
import { StructureAlignmentQuery } from '../auto/alignment/alignment-request';
import { StructureAlignmentResponse } from '../auto/alignment/alignment-response';
import { buildError, isEntry, trimTrailingChars } from '../utils/helper';
import { QueryOptionsImpl, QueryRequest } from '../utils/request';

type AlignmentProviderConfigs = AppConfigs['service']['alignment'];
export class StructureAlignmentService {

    private readonly _config;
    // Delay (in milliseconds) between the last retry and next API call to get the results
    private readonly waitMs;
    // Maximum time (in milliseconds) the application waits to get results from the server
    private readonly timeoutMs;

    constructor(config: AlignmentProviderConfigs) {
        this._config = config;
        this.timeoutMs = config.timeoutMs;
        this.waitMs = config.pollingIntervalMs;
    }

    private submitURL() {
        const base = trimTrailingChars(this._config.base, '/');
        return `${base}/${this._config.submit}`;
    }

    private resultsURL() {
        const base = trimTrailingChars(this._config.base, '/');
        return `${base}/${this._config.results}`;
    }

    /**
     * Submits structure alignment query to the alignment service
     *
     * @param request structure alignment query object that describes the alignment job
     * @returns a unique request ID (UUID) generated at each HTTP request received by the alignment service
     */
    async submit(request: QueryRequest): Promise<string> {
        const data = toFormData(request.query, request.files);
        return fetch(this.submitURL(), {
            method: 'POST',
            body: data,
            headers: this._config.httpHeaders
        }).then(async response => {
            if (response.status === 200)
                return response.text();
            const error = await response.json();
            throw new Error(`Failed to submit the job to the server: ${this.submitURL()}. HTTP ${error.status}: ${error.message}`);
        }).catch(error => {
            throw new Error(`Failed to submit the job to the server: ${this.submitURL()}. Error: ${(error as Error).message}`);
        });
    }

    /**
     * Get structure alignment results calculated by the alignment service
     *
     * @param uuid a unique request ID generated by alignment service
     * @returns structure alignment data
     */
    async results(uuid: string): Promise<StructureAlignmentResponse> {
        const start = Date.now();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // check if had to wait for too long before continue to poll
            if (this.timeoutMs !== 0 && Date.now() - start > this.timeoutMs) {
                throw new Error('Did not receive complete results within the time that was prepared to wait');
            }
            const job = await this.poll(uuid);
            if (job.info.status === 'RUNNING') {
                await this.sleep();
            } else if (job.info.status === 'COMPLETE' || job.info.status === 'ERROR') {
                return job;
            } else {
                throw new Error(`Unexpected job status: ${job.info.status}`);
            }
        }
    }

    private async poll(uuid: string): Promise<StructureAlignmentResponse> {
        const url = this.resultsURL() + '?uuid=' + uuid;
        return fetch(url, { method: 'get' })
            .then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    let msg;
                    if (response.status === 404) {
                        msg = `The job results are unavailable. UUID: [ ${uuid} ] can be wrong or the results were already claimed`;
                    } else {
                        msg = `Fatal error occurred: ${response.statusText}`;
                    }
                    return buildError(uuid, msg);
                }
            })
            .catch(error => buildError(uuid, `Failed to fetch results from ${url}: ${(error as Error).message}`));
    }

    private sleep() {
        return new Promise(resolve => setTimeout(resolve, this.waitMs));
    }
}

function returnSequenceData(query: StructureAlignmentQuery) {
    for (const s of query.context.structures) {
        if (!isEntry(s)) return true;
    }
    return false;
}

function toFormData(query: StructureAlignmentQuery, files?: File[]): FormData {
    if (returnSequenceData(query)) {
        const opts = new QueryOptionsImpl();
        opts.return_sequence_data = true;
        query.options = opts;
    }
    const data = new FormData();
    data.append('query', JSON.stringify(query));
    files?.map(f => data.append('files', f));
    return data;
}